# RLS_AI_Chat

Chat application that allows users to query the `superstore` database.

This system demonstrates how RLS (Row Level Security) is used to enforce data access control on the database level, and how it can be used together with AI Agents that perform SQL RAG. 


[Screenshot](SuperstoreRLS.PNG)

## Traditional CRUD App Data Filtering

In a Traditional CRUD App, the backend application code is responsible for user authorization and filtering data. 

```
┌────────────┐
│   Browser  │
│ (Frontend) │
└─────┬──────┘
      │
      │ 1. User logs in
      │    JWT stored in browser
      ▼
┌────────────┐
│   Browser  │
│ JWT Token  │
└─────┬──────┘
      │
      │ 2. User performs action
      │    (API request + JWT)
      ▼
┌────────────────────┐
│ Backend (Node/Py)  │
│────────────────────│
│ - Validate JWT     │
│ - Authorize user   │
│ - Extract user_id  │
│ - Build SQL query  │
│   WHERE user_id=?  │
└─────┬──────────────┘
      │
      │ 3. Filtered query
      ▼
┌────────────────────┐
│     Database       │
│────────────────────│
│ Returns ONLY rows  │
│ requested by query │
│ (No native RLS)    │
└─────┬──────────────┘
      │
      │ 4. Filtered data
      ▼
┌────────────┐
│   Browser  │
│   UI View  │
└────────────┘

```

## LLM Chatbot with SQL RAG

For AI Agents that perform tool calling to obtain SQL data, we cannot trust the AI Agent to enforce user authorization and data filtering. A malicious user could use prompt injection to impersonate another user, resulting in unauthorized data access. 

LLMs should never be trusted for user access control. As such, Row Level Security should be enforced on the database level. 

```
┌────────────┐
│   Browser  │
│ (Chat UI)  │
└─────┬──────┘
      │
      │ 1. User logs in
      │    JWT stored in browser
      ▼
┌────────────┐
│   Browser  │
│ JWT Token  │
└─────┬──────┘
      │
      │ 2. User sends message
      │    "Show my orders"
      ▼
┌────────────────────┐
│  AI Agent (LLM)    │
│────────────────────│
│ - Receives message │
│ - Chooses SQL tool │
│ - Generates query  │
│   (NO user filter) │
└─────┬──────────────┘
      │
      │ 3. SQL execution
      │    (JWT → DB session)
      ▼
┌────────────────────┐
│   Database (RLS)   │
│────────────────────│
│ - RLS enabled      │
│ - Reads user_id    │
│   from session     │
│ - Filters rows     │
│   automatically    │
└─────┬──────────────┘
      │
      │ 4. Safe result set
      ▼
┌────────────────────┐
│  AI Agent (LLM)    │
│────────────────────│
│ - Interprets rows  │
│ - Generates answer │
└─────┬──────────────┘
      │
      ▼
┌────────────┐
│   Browser  │
│ Chat Reply │
└────────────┘
```

## Supabase + Langchain Implementation

Supabase has built in identity and automates JWT handling.  

We will use Langchain to create an AI Agent that calls a tool to connect to a scoped Supabase client. 

### High-Level Architecture
1) Frontend: Sends the user's prompt and authentication cookies/headers to your Next.js API route.

2) API Route:

- Extracts the access_token (JWT) from the request.
- Initializes a Tool that uses this specific JWT to create a scoped Supabase client.
- Passes this tool to the LangChain Agent.

3) Supabase: Receives the query with the user's JWT, automatically applying RLS policies.

### Key Features
*Authentication & Session Management*

We use @supabase/ssr to manage cookies. The middleware.ts ensures that only authenticated users can access the chat interface, and the `lib/supabase/server.ts` helper provides a secure way to access the session on the server.

*Defining the Scoped Tool*
The tool is defined with a Zod schema so the LLM knows what arguments to provide. Inside the tool's execution block, a dedicated Supabase client is initialized:

```TypeScript
const supabase = createClient(URL, ANON_KEY, {
  global: { headers: { Authorization: `Bearer ${token}` } }
});
```


*Agent Orchestration (LangGraph)*
We use createReactAgent from LangGraph. This creates a loop where the LLM can:

- Reason about the user's question.
- Decide to call the search_superstore tool.
- Observe the data returned.
- Provide a final answer.

*The System Prompt*
The agent is given a specific persona. It is instructed to:

- Use Markdown Tables for data visualization.
- Format numbers as Currency.
- Never reveal technical implementation details (like "I am using RLS").

*Responsive Chat UI*
The frontend uses a Fixed-Height Flexbox layout:

- Header/Footer: Pinned using shrink-0.
- Message List: Occupies flex-1 with a dedicated ScrollArea.
- Markdown Rendering: Uses react-markdown and remark-gfm to render the tables generated by the AI.


## Theoretical Postgres Implementation

In a normal Postgres database, we need to implement the following ourselves:
- Authentication (who is the user?)
- Passing the JWT when making the database call

### Example database set up
Create a database table with a uuid column and enable row level security

```SQL
CREATE TABLE orders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  total numeric,
  created_at timestamptz DEFAULT now()
);

ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
```

Then, we create RLS policies
```SQL
CREATE POLICY user_orders
ON orders
FOR SELECT
USING (user_id = current_setting('app.user_id')::uuid);

CREATE POLICY insert_own_orders
ON orders
FOR INSERT
WITH CHECK (user_id = current_setting('app.user_id')::uuid);
```

### Obtain JWT
In our chat app, we need to implement an authentication system that returns a JWT when the user signs in. 

Auth systems:
- Auth.js / NextAuth
- Clerk
- Auth0

Example JWT
```
{
  "sub": "7c8c4f1a-5c25-4c21-9f6e-9e7c7fcb9f11",
  "email": "user@example.com"
}
```

### Pass JWT to Postgres Query
```TS
import { Pool } from "pg";
import jwt from "jsonwebtoken";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

export async function getOrders(authToken: string) {
  const payload = jwt.verify(authToken, process.env.JWT_SECRET);

  const client = await pool.connect();
  try {
    await client.query("BEGIN");

    await client.query(
      "set local app.user_id = $1",
      [payload.sub]
    );

    const result = await client.query("select * from orders");
    return result.rows;
  } finally {
    await client.query("COMMIT");
    client.release();
  }
}
```


